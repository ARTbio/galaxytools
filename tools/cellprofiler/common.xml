<tool id="cp_common" name="Cellprofiler common start modules" version="@CP_VERSION@">
    <description>
        The first 4 modules in Cellprofiler to start a pipeline, namely Images,Metadata, NameAndTypes, Groups 
    </description>
    <macros>
        <import>macros.xml</import>
        <xml name="image_type_condition"> 
            <conditional name="con_set_intensity">
                <param name="set_intensity_range_from" type="select" label="Set intensity range from">
                    <option value="Image metadata">Image metadata</option>
                    <option value="Image bit-depth">Image bit-depth</option>
                    <option value="Manual">Manual</option>
                </param>
                    <when value="Manual">
                        <param name="maximum_intensity" type="float" value="255.0" label="Maximum intensity"/>
                    </when>
                    <when value="Image metadata">
                    </when>
                    <when value="Image bit-depth">
                    </when>
            </conditional>
        </xml>
        <xml name="name_type_rule_matching_file">
            <param name="operator" type="select">
                <option value="does">Does</option>
                <option value="doesnot">Doesnot</option>
            </param>
            <param name="contain" type="select">
                <option value="contain">Contain</option>
                <option value="Contain regular expression">Contain regular expression</option>
                <option value="startwith">Start with</option>
                <option value="endwith">End with</option>
                <option value="Exactly match">Exactly match</option>
            </param>
            <param name="match_value" type="text"/>
        </xml>
        <xml name="image_matching_rules">
            <repeat name="r_match_rule" title="Rules">
                <param name="match_all_any" type="select" display="radio" label="Match the following rules">
                    <option value="and">All</option>
                    <option value="or">Any</option>
                </param>
                <conditional name="con_match">
                      <param name="rule_type" type="select" label="Select rule criteria">
                          <option value="file">File</option>
                          <option value="directory">Directory</option>
                          <option value="extension">Extension</option>
                          <option value="image">Image</option>
                          <option value="metadata">Metadata</option>
                      </param>
                      <when value="file">
                          <expand macro="name_type_rule_matching_file"/>
                      </when>
                      <when value="directory">
                          <expand macro="name_type_rule_matching_file"/>
                      </when>
                      <when value="extension">
                      </when>
                      <when value="image">
                      </when>
                      <when value="metadata">
                      </when>
                </conditional>
                <param name="name_to_assign" label="Name to assign these images" type="text" />
                <conditional name="con_select_image_type">
                    <param name="select_image_type" type="select" label="Select the image type">
                        <option value="Grayscale image">Grayscale image</option>
                        <option value="Color image">Color image</option>
                        <option value="Binary mask">Binary mask</option>
                    </param>
                    <when value ="Grayscale image">
                        <expand macro="image_type_condition" />
                    </when>
                    <when value="Color image">
                        <expand macro="image_type_condition" />
                    </when>
                    <when value="Binary mask">
                    </when>
                </conditional>
            </repeat>
        </xml>
    </macros>
    <expand macro="requirements" version="@PY_VERSION@" package="python" />
    <expand macro="stdio" />
    <command><![CDATA[
        python '$script_file' '$inputs'
    ]]></command>

    <configfiles>
        <inputs name="inputs" filename="input.json" />
        <configfile name="script_file">
import json
import sys
import os


FOURSPACES=@SPACES@
NEWLINE=@NEWLINE@

input_json_path = sys.argv[1]


params = json.load(open(input_json_path, "r"))

def write_images():
  filter_images = params['images']['filter_images']

  f.write(NEWLINE)
  f.write("Images:[module_num:1|svn_version:\\'Unknown\\'|variable_revision_number:2|show_window:False|notes:\\x5B\\'To begin creating your project, use the Images module to compile a list of files and/or folders that you want to analyze. You can also specify a set of rules to include only the desired files in your selected folders.\\'\x5D|batch_state:array(\x5B\x5D, dtype=uint8)|enabled:True|wants_pause:False]"+NEWLINE)

  f.write(FOURSPACES+":"+NEWLINE)
  f.write(FOURSPACES+"Filter images?:"+filter_images+NEWLINE)
  f.write(FOURSPACES+"Select the rule criteria:and (extension does isimage) (directory doesnot startwith \".\")")
  f.write(NEWLINE)


def write_metadata():
  metadata_extraction = params['metadata']['con_metadata_extraction']
  extract = metadata_extraction['extract']

  if 'extraction_method' in metadata_extraction:
    method_count = str(len(metadata_extraction['extraction_method']))
  else:
    method_count = "1"

  f.write(NEWLINE)
  f.write("Metadata:[module_num:2|svn_version:\\'Unknown\\'|variable_revision_number:4|show_window:False|notes:\\x5B\\'The Metadata module optionally allows you to extract information describing your images (i.e, metadata) which will be stored along with your measurements. This information can be contained in the file name and/or location, or in an external file.\\'\x5D|batch_state:array(\x5B\x5D, dtype=uint8)|enabled:True|wants_pause:False]"+NEWLINE)

  f.write(FOURSPACES+"Extract metadata?:"+extract+NEWLINE)  
  
  if extract=="No":
    f.write(FOURSPACES+"Metadata data type:Text"+NEWLINE)
    f.write(FOURSPACES+"Metadata types:{}"+NEWLINE)
    f.write(FOURSPACES+"Extraction method count:"+method_count+NEWLINE)
    f.write(FOURSPACES+"Metadata extraction method:Extract from file/folder names"+NEWLINE)
    f.write(FOURSPACES+"Regular expression to extract from file name:^(?P&lt;Plate>.*)_(?P&lt;Well>\x5BA-P\x5D\x5B0-9\x5D{2})_s(?P&lt;Site>\x5B0-9\x5D)_w(?P&lt;ChannelNumber>\x5B0-9\x5D)"+NEWLINE)
    f.write(FOURSPACES+"Regular expression to extract from folder name:(?P&lt;Date>\x5B0-9\x5D{4}_\x5B0-9\x5D{2}_\x5B0-9\x5D{2})$"+NEWLINE)
    f.write(FOURSPACES+"Extract metadata from:All images"+NEWLINE)
    f.write(FOURSPACES+"Select the filtering criteria:and (file does contain \"\")"+NEWLINE)
    f.write(FOURSPACES+"Metadata file location:"+NEWLINE)
    f.write(FOURSPACES+"Match file and image metadata:\x5B\x5D"+NEWLINE)
    f.write(FOURSPACES+"Use case insensitive matching?:No"+NEWLINE)
  else:
    f.write(FOURSPACES+"Metadata data type:"+metadata_extraction['metadata_type']+NEWLINE)
    f.write(FOURSPACES+"Metadata types:{}"+NEWLINE)
    f.write(FOURSPACES+"Extraction method count:"+method_count+NEWLINE)    

    for methods in metadata_extraction["extraction_method"]:
      f.write(FOURSPACES+"Metadata extraction method:"+methods["metadata_extraction_method"]+NEWLINE)
      f.write(FOURSPACES+"Metadata source:"+methods["metadata_source"]+NEWLINE)
      f.write(FOURSPACES+"Regular expression to extract from file name:"+methods["file_name_regex"]+NEWLINE)
      f.write(FOURSPACES+"Regular expression to extract from folder name:"+methods["folder_name_regex"]+NEWLINE)
      f.write(FOURSPACES+"Extract metadata from:"+methods["extract_metadata_from"]+NEWLINE)
      f.write(FOURSPACES+"Select the filtering criteria:and (file does contain \"\")"+NEWLINE)
      f.write(FOURSPACES+"Metadata file location:"+NEWLINE)
      f.write(FOURSPACES+"Match file and image metadata:\x5B\x5D"+NEWLINE)
      f.write(FOURSPACES+"Use case insensitive matching?:No"+NEWLINE)


def write_nameandtypes():
  nameandtypes = params['nameandtypes']  
  assign_a_name = nameandtypes['con_assign_a_name_to']['assign_a_name_to']

  if "con_select_image_type" in nameandtypes['con_assign_a_name_to']:
      con_set_intensity = nameandtypes['con_assign_a_name_to']['con_select_image_type']['con_set_intensity']
      max_intensity= con_set_intensity['maximum_intensity'] if "maximum_intensity" in con_set_intensity else "255.0"
  else:
      max_intensity = "255.0"
  
  pixel_space = nameandtypes['pixel_space']

  rule_count = str(len(nameandtypes['r_match_rule'])) if "r_match_rule" in nameandtypes else "1"
  

  process_3d = nameandtypes['pixel_space']['process_3d']
  x_spacing = "1.00" if "x_spacing" not in pixel_space else pixel_space["x_spacing"]
  y_spacing = "1.00" if "y_spacing" not in pixel_space else pixel_space["y_spacing"]
  z_spacing = "1.00" if "z_spacing" not in pixel_space else pixel_space["z_spacing"]

  f.write(NEWLINE)
  f.write("NamesAndTypes:[module_num:3|svn_version:\\'Unknown\\'|variable_revision_number:8|show_window:False|notes:\\x5B\\'The NamesAndTypes module allows you to assign a meaningful name to each image by which other modules will refer to it.\\'\\x5D|batch_state:array(\\x5B\\x5D, dtype=uint8)|enabled:True|wants_pause:False]"+NEWLINE)

  f.write(FOURSPACES+"Asign a name to:"+assign_a_name+NEWLINE)

  if assign_a_name =="All images":
      f.write(FOURSPACES+"Select the image type:"+nameandtypes['con_assign_a_name_to']['con_select_image_type']['select_image_type']+NEWLINE)
      f.write(FOURSPACES+"Name to assign these images:"+nameandtypes['con_assign_a_name_to']['name_to_assign']+NEWLINE)
      f.write(FOURSPACES+"Match metadata:[]"+NEWLINE)
      f.write(FOURSPACES+"Image set matching method:Order"+NEWLINE)
      f.write(FOURSPACES+"Set intensity range from:"
                        +con_set_intensity['set_intensity_range_from']
                        +NEWLINE)
      f.write(FOURSPACES+"Assignments count:"+rule_count+NEWLINE)
      f.write(FOURSPACES+"Single images count:0"+NEWLINE)
      f.write(FOURSPACES+"Maximum intensity:"+max_intensity+NEWLINE)
      f.write(FOURSPACES+"Process as 3D?:"+process_3d+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in X:"+x_spacing+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in Y:"+y_spacing+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in Z:"+z_spacing+NEWLINE)
  else:
      f.write(FOURSPACES+"Select the image type:Grayscale image"+NEWLINE)
      f.write(FOURSPACES+"Name to assign these images:DNA"+NEWLINE)
      f.write(FOURSPACES+"Match metadata:[]"+NEWLINE)
      f.write(FOURSPACES+"Image set matching method:"+nameandtypes['con_assign_a_name_to']['matching_method']+NEWLINE)
      f.write(FOURSPACES+"Set intensity range from:Image metadata"+NEWLINE)
      f.write(FOURSPACES+"Assignments count:"+rule_count+NEWLINE)
      f.write(FOURSPACES+"Single images count:0"+NEWLINE)
      f.write(FOURSPACES+"Maximum intensity:"+max_intensity+NEWLINE)
      f.write(FOURSPACES+"Process as 3D?:"+process_3d+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in X:1.00"+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in Y:1.00"+NEWLINE)
      f.write(FOURSPACES+"Relative pixel spacing in Z:1.00"+NEWLINE)  

      for rule in nameandtypes["con_assign_a_name_to"]["r_match_rule"]:
          f.write(FOURSPACES+"Select the rule criteria:"+ rule["match_all_any"] +" ("+rule["con_match"]["rule_type"]+" "+rule["con_match"]["operator"]+" "+rule["con_match"]["contain"]+" \""+rule["con_match"]["match_value"]+"\")"+NEWLINE)
          f.write(FOURSPACES+"Name to assign these images:"+rule["name_to_assign"]+NEWLINE)
          f.write(FOURSPACES+"Name to assign these objects:Cell"+NEWLINE)
          f.write(FOURSPACES+"Select the image type:"+rule["con_select_image_type"]["select_image_type"]+NEWLINE)

          intensity_range = rule["con_select_image_type"]["con_set_intensity"]["set_intensity_range_from"]
          f.write(FOURSPACES+"Set intensity range from:"+intensity_range+NEWLINE)
          f.write(FOURSPACES+"Select the image type:"+rule["con_select_image_type"]["select_image_type"]+NEWLINE)

          if intensity_range=="Manual":
              f.write(FOURSPACES+"Maximum intensity:"+rule["con_select_image_type"]["con_set_intensity"]["maximum_intensity"]+NEWLINE)
          else:
              f.write(FOURSPACES+"Maximum intensity:255.0"+NEWLINE)

          if process_3d =="Yes":
              f.write(FOURSPACES+"Relative pixel spacing in X:"+x_spacing+NEWLINE)
              f.write(FOURSPACES+"Relative pixel spacing in Y:"+y_spacing+NEWLINE)
              f.write(FOURSPACES+"Relative pixel spacing in Z:"+z_spacing+NEWLINE) 



def write_groups():
  groups=params['groups']  

  f.write(NEWLINE)
  
  f.write("Groups:[module_num:4|svn_version:\\'Unknown\\'|variable_revision_number:2|show_window:False|notes:\\x5B\\\'The Groups module optionally allows you to split your list of images into image subsets (groups) which will be processed independently of each other. Examples of groupings include screening batches, microtiter plates, time-lapse movies, etc.\\'\\x5D|batch_state:array(\\x5B\\x5D, dtype=uint8)|enabled:True|wants_pause:False]"+NEWLINE)

  f.write(FOURSPACES+"Do you want to group your images?:"+groups["con_groups"]["group_images"]+NEWLINE)
  f.write(FOURSPACES+"grouping metadata count:1"+NEWLINE)
  f.write(FOURSPACES+"Metadata category:"+groups["con_groups"]["group_category"]+NEWLINE)


with open("output","w") as f:
  headers = ["CellProfiler Pipeline: http://www.cellprofiler.org\n",
             "Version:3\n",
             "DateRevision:319\n",
             "GitHash:\n",
             "ModuleCount:4\n",
             "HasImagePlaneDetails:False",
             "\n"]

  f.writelines(headers)

  write_images()
  write_metadata()
  write_nameandtypes()
  write_groups()

  f.close()

        </configfile>
    </configfiles>
    <inputs>    
<!-- Images module-->
        <section name="images" title="Images" expanded="false">
            <param name="filter_images" type="select" label="Filer images?">
              <option value="Images only">Images only</option>
              <option value="No filtering">No filtering</option>
            </param>
        </section>
    <!-- Metadata module-->
        <section name="metadata" title="Metadata" expanded="false">
            <conditional name="con_metadata_extraction">
                <param name="extract" type="select" display="radio" label="Extract metadata?">
                    <option value="No">No</option>
                    <option value="Yes">Yes</option>
                </param>
                <when value="Yes">
                    <repeat name="extraction_method" title="metadata">
                        <param name="metadata_extraction_method" type="select" label="Metadata extraction method">
                            <option value="Extract from file/folder names">Extract from file/folder names</option>
                            <option value="Import from file">Import from file</option>
                            <option value="Extract from image file headers">Extract from image file headers</option>
                        </param>
                        <param name="metadata_source" type="select" label="Metadata source">
                            <option value="File name">File name</option>
                            <option value="Folder name">Folder name</option>
                        </param>
                        <param name="file_name_regex" type="text" value="^(?P&lt;Plate>.*)_(?P&lt;Well>[A-P][0-9]{2})_s(?P&lt;Site>[0-9])_w(?P&lt;ChannelNumber>[0-9])" label="Regular expression to extract from file name">    
                            <sanitizer sanitize="false"/>
                        </param>
                        <param name="folder_name_regex" type="text" value="(?P&lt;Date>[0-9]{4}_[0-9]{2}_[0-9]{2})$" label="Regular expression to extract from folder name"> 
                            <sanitizer sanitize="false"/>
                        </param>
                        <param name="extract_metadata_from" type="select" label="Extract metadata from">
                            <option value="All images">All images</option>
                            <option value="Images matching a rule">Images matching a rule</option>
                        </param>
                    </repeat>
                    <param name="metadata_type" type="select" label="Metadata data type">      
                        <option value="Text">Text</option>
                    </param>
                </when>
                <when value="No">
                </when>
            </conditional>
        </section>
    <!-- NamesAndTypes-->
        <section name="nameandtypes" title="NamesAndTypes" expanded="false">
            <conditional name="pixel_space">
                <param name="process_3d" type="select" display="radio" label="Process 3D">
                    <option value="No">No</option>
                    <option value="Yes">Yes</option>
                </param>  
                <when value="Yes">
                    <param name="x_spacing" type="float" value="1.0" label="Relative pixel spacing in X"/>
                    <param name="y_spacing" type="float" value="1.0" label="Relative pixel spacing in Y"/>
                    <param name="z_spacing" type="float" value="1.0" label="Relative pixel spacing in Z"/>
                </when>
                <when value="No">
                </when>
            </conditional>
            <conditional name="con_assign_a_name_to">
                <param name="assign_a_name_to" type="select" label="Assign a name to">
                    <option value="All images">All images</option>
                    <option value="Images matching rules">Images matching rules</option>
                </param>
                <when value="All images">
                    <param name="name_to_assign" type="text" value="DNA" label="Name to assign these images"/>
                    <conditional name="con_select_image_type">
                        <param name="select_image_type" type="select" label="Select the image type">
                            <option value="Grayscale image">Grayscale image</option>
                            <option value="Color image">Color image</option>
                            <option value="Binary mask">Binary mask</option>
                        </param>
                        <when value ="Grayscale image">
                            <expand macro="image_type_condition" />
                        </when>
                        <when value="Color image">
                            <expand macro="image_type_condition" />
                        </when>
                        <when value="Binary mask">
                        </when>
                    </conditional>
                </when>
                <when value="Images matching rules">
                    <expand macro="image_matching_rules"/>
                    <param name="matching_method" type="select" label="Image set matching method">
                        <option value="Order">Order</option>
                        <option value="Metadata">Metadata</option>
                    </param>
                </when>
            </conditional>
        </section>
    <!-- Groups -->
        <section name="groups" title="Groups" expanded="false">
            <conditional name="con_groups">
                <param name="group_images" type="select" value="No" label="Do you want to group your images?" display="radio">
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                </param>
                <when value="Yes">
                    <param name="group_category" type="select" label="Metadata category">
                        <option value="FileLocation">FileLocation</option>
                        <option value="Frame">Frame</option>
                        <option value="ImageId">ImageId</option>
                        <option value="Screen">Screen</option>
                        <option value="Series">Series</option>
                    </param>
                </when>
                <when value="No">
                </when>
            </conditional>
        </section>
    </inputs>
    <outputs>
        <expand macro="output_pipeline_macro" />
    </outputs>
    <tests>
        <test>
            <param name="filter_images" value="Images only"/>
            <conditional name="con_metadata_extraction">
                <param name="extract" value="Yes"/>
                <repeat name="extraction_method">
                    <param name="metadata_extraction_method" value="Extract from file/folder names"/>
                    <param name="metadata_source" value="File name" />
                    <param name="file_name_regex" value="^im_(?P&lt;Screen>.*)_(?P&lt;ImageId>[0-9]+).tiff" />
                    <param name="extract_metadata_from" value="All images" />
                </repeat>
                <param name="metadata_type" value="Text" />
            </conditional>
            <conditional name="pixel_space">
                <param name="process_3d" value="No"/>
            </conditional>
            <conditional name="con_assign_a_name_to">
                <param name="assign_a_name_to" value="Images matching rules"/>
                <repeat name="r_match_rule">
                    <param name="match_all_any" value="and" />
                    <conditional name="con_match">
                        <param name="rule_type" value="file" />
                        <param name="operator" value="does" />
                        <param name="contain" value="startwith" />
                        <param name="match_value" value="im" /> 
                    </conditional>
                    <param name="name_to_assign" value="DNA" />
                    <conditional name="con_select_image_type">
                        <param name="select_image_type" value="Grayscale image" />
                        <conditional name="con_set_intensity">
                            <param name="set_intensity_range_from" value="Image metadata" />
                        </conditional>
                    </conditional>
                </repeat>
                <param name="matching_method" value="Order" />
            </conditional>
            <conditional name="con_groups">
                <param name="group_images" value="Yes" />
                <param name="group_category" value="Screen" />
            </conditional>
            <expand macro="test_out_file" />
        </test>
    </tests>

    <help>
    This tool builds a Cellprofiler pipeline file with headers and 4 compulsory modules, 'Images', 'Metadata', 'NamesAndTypes' and 'Groups'.

    No input parameters are needed for this tool. The rest CP modules will build based on the output of this file.

 
    Images: use the Images module to compile a list of files that you want to analyze. 

    Metadata: optionally allows you to extract information describing your images (i.e., metadata) which will be stored along with your measurements. 

    NamesAndTypes: allows you to assign a meaningful name to each image by which other modules will refer to it.

    Groups: optionally allows you to split your list of images into image subsets (groups) which will be processed independently of each other. Examples of groupings include screening batches, microtiter plates, time-lapse movies, etc.

    </help>
    <expand macro="citations" />
</tool>

