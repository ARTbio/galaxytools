<tool id="cp_identify_primary_objects" name="IdentifyPrimaryObjects" version="@CP_VERSION@">
    <description>identify biological objects of interest</description>

    <macros>
        <import>macros.xml</import>
        <xml name="ipo_common">
            <param name="input_from_nat" type="text" label="Enter the name of the input image (from NamesAndTypes)">
                <expand macro="text_validator" />
            </param>
            <param name="name_to_be_identified" type="text" label="Enter the name of the primary objects to be identified">
                <expand macro="text_validator" />
            </param>
            <param name="min_diameter" type="integer" label="Typical minimum diameter of objects, in pixel units (Min)" value="10" min="0">
                <help>
                    <![CDATA[
                        The min and max diameters are crucial for two reasons: first, the module uses it to calculate certain automatic settings in order to identify your objects of interest properly (see below). Second, when used in conjunction with the 'Discard objects outside the diameter range?' setting below, you can choose to remove objects outside the size range you provide here.
                        ]]>
                </help>
            </param>
            <param name="max_diameter" type="integer" label="Typical maximum diameter of objects, in pixel units (Max)" value="40" min="0" />
            <param name="discard_outside_border" type="select" display="radio" label="Discard objects outside the diameter range?">
                <option value="Yes">Yes</option>
                <option value="No">No</option>
            </param>
            <param name="discard_touching_border" type="select" display="radio" label="Discard objects touching the border of the image?">
                <option value="Yes">Yes</option>
                <option value="No">No</option>
            </param>
        </xml>

        <xml name="clumped_objects_params">
            <conditional name="con_smoothing_filter">
                <param name="smoothing_filter" type="select" label="Automatically calculate size of smoothing filter for declumping?">
                    <help>
                        <![CDATA[
                            Select 'Yes' to automatically calculate the amount of smoothing applied to the image to assist in declumping. Select "No" to manually enter the smoothing filter size.
                            This setting, along with the Minimum allowed distance between local maxima setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background.
                            Please note that this smoothing setting is applied after thresholding, and is therefore distinct from the threshold smoothing method setting above, which is applied before thresholding.
                            The size of the smoothing filter is automatically calculated based on the Typical diameter of objects, in pixel units (Min,Max) setting above. If you see too many objects merged that ought to be separate or too many objects split up that ought to be merged, you may want to override the automatically calculated value.
                            ]]>
                    </help>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                </param>
                <when value="No">
                    <param name="size_smoothing_filter" type="integer" label="Size of smoothing filter" min="0" max="1" value="1">
                        <help>
                            <![CDATA[
                                If you see too many objects merged that ought to be separated (under-segmentation), this value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.
                                Note that splitting and merging is also affected by your choice of settings for the setting, Automatically calculate minimum allowed distance between local maxima? It is an art to balance these two settings; read the help carefully for both.
                                Reducing the texture of objects by increasing the smoothing increases the chance that each real, distinct object has only one peak of intensity but also increases the chance that two distinct objects will be recognized as only one object. Note that increasing the size of the smoothing filter increases the processing time exponentially.
                                Enter 0 to prevent any image smoothing in certain cases; for example, for low resolution images with small objects ( < ~5 pixels in diameter).
                                ]]>
                        </help>
                    </param>
                </when>
                <when value="Yes" />
            </conditional>
            <conditional name="con_min_distance">
                <param name="min_distance" type="select" label="Automatically calculate minimum allowed distance between local maxima?">
                    <help>
                        <![CDATA[
                            Select "Yes" to automatically calculate the distance between intensity maxima to assist in declumping. Select "No" to manually enter the permissible maxima distance.
                            This setting, along with the Size of smoothing filter setting, affects whether objects close to each other are considered a single object or multiple objects. It does not affect the dividing lines between an object and the background. Local maxima that are closer together than the minimum allowed distance will be suppressed (the local intensity histogram is smoothed to remove the peaks within that distance).
                            The distance can be automatically calculated based on the minimum entered for the Typical diameter of objects, in pixel units (Min,Max) setting above, but if you see too many objects merged that ought to be separate, or too many objects split up that ought to be merged, you may want to override the automatically calculated value.
                            ]]>
                    </help>
                    <option value="Yes">Yes</option>
                    <option value="No">No</option>
                </param>
                <when value="No">
                    <param name="min_allowed_distance" type="integer" label="Supress local maxima that are closer than this minimum allowed distance" value="7">
                        <help>
                            <![CDATA[
                                Enter a positive integer, in pixel units. If you see too many objects merged that ought to be separated (under-segmentation), the value should be lower. If you see too many objects split up that ought to be merged (over-segmentation), the value should be higher.
                                The maxima suppression distance should be set to be roughly equivalent to the radius of the smallest object of interest that you would expect to see in the experiment.
                                Any distinct 'objects' that are found but are within two times this distance from each other will be assumed to be actually two lumpy parts of the same object, and they will be merged.
                                Note that splitting and merging is also affected by your choice of settings for the setting 'Size of smoothing filter'.
                                ]]>
                        </help>
                    </param>
                </when>
                <when value="Yes" />
            </conditional>
            <param name="speed_up" type="select" display="radio" label="Speed up by using lower-resolution image to find local maxima?">
                <help>
                    <![CDATA[
                        Select 'Yes' to down-sample the image for declumping. This can be helpful for saving processing time on large images.
                        Note that if you have entered a minimum object diameter of 10 or less, checking this box will have no effect.
                        ]]>
                </help>
                <option value="Yes">Yes</option>
                <option value="No">No</option>
            </param>
        </xml>

        <xml name="clumped_objects">
            <conditional name="con_dividing_lines">
                <param name="dividing_lines" type="select" label="Method to draw dividing lines between clumped objects">
                    <help>
                        <![CDATA[
                            This setting allows you to choose the method that is used to draw the line between segmented objects, provided that you have chosen to declump the objects. To decide between these methods, you can run Test mode to see the results of each.
                            <br> - Intensity: Works best where the dividing lines between clumped objects are dimmer than the remainder of the objects.
                            <br> - Technical description: Using the previously identified local maxima as seeds, this method is a watershed (Vincent and Soille, 1991) on the intensity image.
                            <br> - Shape: Dividing lines between clumped objects are based on the shape of the clump. For example, when a clump contains two objects, the dividing line will be placed where indentations occur between the two objects. The intensity patterns in the original image are largely irrelevant: the cells need not be dimmer along the lines between clumped objects. Technical description: Using the previously identified local maxima as seeds, this method is a watershed on the distance-transformed thresholded image.
                            <br> - Propagate: This method uses a propagation algorithm instead of a watershed. The image is ignored and the pixels are assigned to the objects by repeatedly adding unassigned pixels to the objects that are immediately adjacent to them. This method is suited in cases such as objects with branching extensions, for instance neurites, where the goal is to trace outward from the cell body along the branch, assigning pixels in the branch along the way. See the help for the IdentifySecondaryObjects module for more details on this method.
                            <br> - None: If objects are well separated and bright relative to the background, it may be unnecessary to attempt to separate clumped objects. Using the very fast None option, a simple threshold will be used to identify objects.
                            ]]>
                    </help>
                    <option value="Intensity">Intensity</option>
                    <option value="Shape">Shape</option>
                    <option value="Propagate">Propagate</option>
                    <option value="None">None</option>
                </param>
                <when value="Shape">
                    <expand macro="clumped_objects_params"/>
                </when>
                <when value="Intensity">
                    <expand macro="clumped_objects_params"/>
                </when>
                <when value="Propagate"/>
                <when value="None"/>
            </conditional>
        </xml>
    </macros>

    <expand macro="py_requirements"/>
    <expand macro="cmd_modules" />

    <configfiles>
        <inputs name="inputs" />

        <configfile name="script_file">
            import json
            import sys
            import os

            FOURSPACES=@SPACES@

            input_json_path = sys.argv[1]
            input_pipeline= sys.argv[2]

            params = json.load(open(input_json_path, "r"))

            ipo = params['con_advanced']

            adv = params['con_advanced']['advanced']


            def write_ipo():
            _str = "\nIdentifyPrimaryObjects:[module_num:%d|svn_version:\\'Unknown\\'|variable_revision_number:13|show_window:True|notes:\\x5B\\'Identify the nuclei from the DNA channel.\\', \\'PARAMS\\x3A\\', \\'- Typical diameter of objects (Min,Max)\\', \\'- Method to distinguish clumped objects\\x3A Shape/None. With Shape, the distance between the 2 centers can be changed.\\'\\x5D|batch_state:array(\\x5B\\x5D, dtype=uint8)|enabled:True|wants_pause:False]\n" % new_count

            if adv == "Yes":
            _str += FOURSPACES + "Select the input image:%s\n" % ipo['input_from_nat']
            _str += FOURSPACES + "Name the primary objects to be identified:%s\n" % ipo['name_to_be_identified']
            _str += FOURSPACES + "Typical diameter of objects, in pixel units (Min,Max):%d,%d\n" % (ipo['min_diameter'], ipo['max_diameter'])
            _str += FOURSPACES + "Discard objects outside the diameter range?:%s\n" % ipo['discard_outside_border']
            _str += FOURSPACES + "Discard objects touching the border of the image?:%s\n" % ipo['discard_touching_border']

            _str += FOURSPACES + "Method to distinguish clumped objects:%s\n" % ipo['con_distinguish_clumped_objects']['distinguish_clumped_objects']

            if "con_dividing_lines" in ipo['con_distinguish_clumped_objects']:
            smoothing = ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter'][
            'smoothing_filter']
            supress = ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_distance']

            _str += FOURSPACES + "Method to draw dividing lines between clumped objects:%s\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['dividing_lines']

            if smoothing == "Yes":
            _str += FOURSPACES + "Size of smoothing filter:0\n"
            else:
            _str += FOURSPACES + "Size of smoothing filter:%d\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter']['size_smoothing_filter']

            if supress == "Yes":
            _str += FOURSPACES + "Suppress local maxima that are closer than this minimum allowed distance:7\n"
            else:
            _str += FOURSPACES + "Suppress local maxima that are closer than this minimum allowed distance:%d\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_allowed_distance']

            _str += FOURSPACES + "Speed up by using lower-resolution image to find local maxima?:%s\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['speed_up']

            _str += FOURSPACES + "Fill holes in identified objects?:%s\n" % ipo['fill_hole']

            if "con_dividing_lines" in ipo['con_distinguish_clumped_objects']:
            _str += FOURSPACES + "Automatically calculate size of smoothing filter for declumping?:%s\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter']['smoothing_filter']
            _str += FOURSPACES + "Automatically calculate minimum allowed distance between local maxima?:%s\n" % ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_distance']

            if "con_handling_excessive" in ipo:
            excessive = ipo['con_handling_excessive']['excessive_handling']

            _str += FOURSPACES + "Handling of objects if excessive number of objects identified:%s\n" % ipo['con_handling_excessive']['excessive_handling']
            if excessive == "Continue":
            _str += FOURSPACES + "Maximum number of objects:500\n"
            else:
            _str += FOURSPACES + "Maximum number of objects:%d\n" + ipo['con_handling_excessive']['max_obj']

            _str += FOURSPACES + "Use advanced settings?:%s\n" % ipo['advanced']
            _str += FOURSPACES + "Threshold settings version:10\n"
            _str += FOURSPACES + "Threshold strategy:%s\n" % ipo['con_threshold_strategy']['threshold_strategy']

            threshold_method = ipo['con_threshold_method']['threshold_method']
            _str += FOURSPACES + "Thresholding method:%s\n" % threshold_method

            _str += FOURSPACES + "Threshold smoothing scale:%.4f\n" % ipo['threshold_smoothing_scale']
            _str += FOURSPACES + "Threshold correction factor:%.1f\n" % ipo['threshold_correction_factor']
            _str += FOURSPACES + "Lower and upper bounds on threshold:%.1f,%.1f\n" % (ipo['threshold_lower'], ipo['threshold_upper'])

            if threshold_method == "Manual":
            _str += FOURSPACES + "Manual threshold:%d\n" % ipo['con_threshold_method']['manual_threshold']
            else:
            _str += FOURSPACES + "Manual threshold:0\n"

            if threshold_method == "Measurement":
            _str += FOURSPACES + "Select the measurement to threshold with:%s\n" % ipo['con_threshold_method']['threshold_measurement']
            else:
            _str += FOURSPACES + "Select the measurement to threshold with:None\n"

            threshold_class = ipo['con_threshold_method']['con_threshold_class']['threshold_class']
            _str += FOURSPACES + "Two-class or three-class thresholding?:%s\n" % threshold_class

            if threshold_class == "Three classes":
            _str += FOURSPACES + "Assign pixels in the middle intensity class to the foreground or the background?:%s\n" % threshold_class['assign_pixel']
            else:
            _str += FOURSPACES + "Assign pixels in the middle intensity class to the foreground or the background?:Foreground\n"

            if ipo['con_threshold_strategy']['threshold_strategy'] == "Adaptive":
            _str += FOURSPACES + "Size of adaptive window:%d\n" + ipo['con_threshold_strategy']['adaptive_window']
            else:
            _str += FOURSPACES + "Size of adaptive window:500\n"

            if threshold_method == "RobustBackground":
            _str += FOURSPACES + "Lower outlier fraction:%.2f\n" % ipo['con_threshold_method']['lower_outlier_fraction']
            _str += FOURSPACES + "Upper outlier fraction:%.2f\n" % ipo['con_threshold_method']['upper_outlier_fraction']
            _str += FOURSPACES + "Averaging method:%s\n" % ipo['con_threshold_method']['avg_method']
            _str += FOURSPACES + "Variance method:%s\n" % ['variance_method']
            _str += FOURSPACES + "# of deviations:%.2f\n" % ipo['con_threshold_method']['no_of_deviations']
            else:
            _str += FOURSPACES + "Lower outlier fraction:0.05\n"
            _str += FOURSPACES + "Upper outlier fraction:0.05\n"
            _str += FOURSPACES + "Averaging method:Mean\n"
            _str += FOURSPACES + "Variance method:Standard deviation\n"
            _str += FOURSPACES + "# of deviations:2.0\n"

            _str += FOURSPACES + "Thresholding method:%s\n" % threshold_method    # This is a repeated entry, but needed for pipeline file

            return _str


            with open(input_pipeline) as fin:
            lines = fin.readlines()

            k, v = lines[4].strip().split(':')

            module_count = int(v)
            new_count = module_count + 1
            lines[4] = k + ":%d\n" % new_count
            with open("output", "w") as f:
            f.writelines(lines)
            f.write(write_ipo())

            f.close()
        </configfile>
    </configfiles>

    <inputs>
        <expand macro="input_pipeline_param" />
        <conditional name="con_advanced">
            <param name="advanced" type="select" label="Use advanced settings?">
                <option value="No">No, use basic settings</option>
                <option value="Yes">Yes, use advanced settings</option>
            </param>
            <when value="No">
                <expand macro="ipo_common" />
            </when>
            <when value="Yes">
                <expand macro="ipo_common" />
                <conditional name="con_threshold_strategy">
                    <param name="threshold_strategy" type="select" label="Threshold strategy">
                        <help>
                            <![CDATA[
                                The thresholding strategy determines the type of input that is used to calculate the threshold. These options allow you to calculate a threshold based on the whole image or based on image sub-regions.
                                The choices for the threshold strategy are:

                                <br> - Global: Calculates a single threshold value based on the unmasked pixels of the input image and use that value to classify pixels above the threshold as foreground and below as background.
                                image0 This strategy is fast and robust, especially if the background is relatively uniform (for example, after illumination correction).

                                <br> - Adaptive: Calculates a different threshold for each pixel, thus adapting to changes in foreground/background intensities across the image. For each pixel, the threshold is calculated based on the pixels within a given neighborhood (or window) surrounding that pixel.
                                image1 This method is slower but can produce better results for non-uniform backgrounds. However, for significant illumination variation, using the CorrectIllumination modules is preferable.
                                ]]>
                        </help>
                        <option value="Global">Global</option>
                        <option value="Adaptive" selected="true">Adaptive</option>
                    </param>
                    <when value="Adaptive">
                        <param name="adaptive_window" type="integer" label="Size of the adaptive window" value="50" help="Often a good choice is some multiple of the largest expected object size." />
                    </when>
                    <when value="Global" />
                </conditional>
                <conditional name="con_threshold_method">
                    <param name="threshold_method" type="select" label="Thresholding method">
                        <help>
                            <![CDATA[
                                The intensity threshold affects the decision of whether each pixel will be considered foreground (region(s) of interest) or background.
                                A higher threshold value will result in only the brightest regions being identified, whereas a lower threshold value will include dim regions.
                                When using the strategy "Global", you can have the threshold automatically calculated from a choice of several methods, however, when you choose "Adaptive" as the thresholding strategy, your only option is Otsu automatic thresholding.
                                The threshold that is used for each image is recorded as a per-image measurement, so if you are surprised by unusual measurements from one of your images, you might check whether the automatically calculated threshold was unusually high or low compared to the other images. See the FlagImage module if you would like to flag an image based on the threshold value.

                                <br> - Otsu: This approach calculates the threshold separating the two classes of pixels (foreground and background) by minimizing the variance within the each class.
                                ]]>
                        </help>
                        <!-- Bea: Please check this: when adaptive is selected only otsu is enabled -->
                        <option value="Manual">Manual</option>
                        <option value="Measurement">Measurement</option>
                        <option value="Minimum cross entropy">Minimum cross entropy</option>
                        <option value="Otsu" selected="True">Otsu</option>
                        <option value="RobustBackground">Robust background</option>
                    </param>
                    <when value="Otsu">
                        <conditional name="con_threshold_class">
                            <param name="threshold_class" type="select" label="Two-class or three-class thresholding?">
                                <help>
                                    <![CDATA[
                                        - Two classes: Select this option if the grayscale levels are readily distinguishable into only two classes: foreground (i.e., regions of interest) and background.
                                        <br> - Three classes: Choose this option if the grayscale levels fall instead into three classes: foreground, background and a middle intensity between the two. You will then be asked whether the middle intensity class should be added to the foreground or background class in order to generate the final two-class output.
                                        ]]>
                                </help>
                                <option value="Two classes">Two classes</option>
                                <option value="Three classes">Three classes</option>
                            </param>
                            <when value="Three classes">
                                <param name="assign_pixel" type="select" label="Assign pixels in the middle intensity class to the foreground or the background?" help="Choose whether you want the pixels with middle grayscale intensities to be assigned to the foreground class or the background class.">
                                    <option value="Foreground">Foreground</option>
                                    <option value="Background">Background</option>
                                </param>
                            </when>
                            <when value="Two classes" />
                        </conditional>
                    </when>
                    <when value="Manual">
                        <param name="manual_threshold" type="float" label="Enter the value that will act as an absolute threshold for the images" min="0" max="1" value="0" />
                    </when>
                    <when value="RobustBackground">
                        <param name="lower_outlier_fraction" type="float" value="0.05" min="0.0" max="1.0" label="Lower outlier fraction" />
                        <param name="upper_outlier_fraction" type="float" value="0.05" min="0.0" max="1.0" label="Upper outlier fraction" />
                        <param name="avg_method" type="select" label="Averaging method">
                            <option value="Mean">Mean</option>
                            <option value="Median">Median</option>
                            <option value="Mode">Mode</option>
                        </param>
                        <param name="variance_method" type="select" label="Variance">
                            <option value="Standard deviation">Standard deviation</option>
                            <option value="Median absolute deviation">Median absolute deviation</option>
                        </param>
                        <param name="no_of_deviations" type="float" value="2.0" label="# of deviations">
                            <![CDATA[
                                Robust background calculates the variance, multiplies it by the value given by this setting and adds it to the average.
                                Adding several deviations raises the threshold well above the average. Use a larger number to be more stringent about identifying foreground pixels.
                                Use a smaller number to be less stringent. It’s even possible to use a negative number if you want the threshold to be lower than the average (e.g., for images that are densely covered by foreground).
                                ]]>
                        </param>
                    </when>
                    <when value="Measurement"/>
                    <when value="Minimum cross entropy"/>
                </conditional>
                <param name="threshold_smoothing_scale" type="float" value="1.3488" label="Threshold smoothing scale">
                    <help>
                        <![CDATA[
                            This setting controls the scale used to smooth the input image before the threshold is applied.
                            The input image can be optionally smoothed before being thresholded.
                            Smoothing can improve the uniformity of the resulting objects, by removing holes and jagged edges caused by noise in the acquired image.
                            Smoothing is most likely not appropriate if the input image is binary, if it has already been smoothed or if it is an output of a pixel-based classifier.
                            The scale should be approximately the size of the artifacts to be eliminated by smoothing.
                            A Gaussian is used with a sigma adjusted so that 1/2 of the Gaussian’s distribution falls within the diameter given by the scale (sigma = scale / 0.674) Use a value of 0 for no smoothing.
                            Use a value of 1.3488 for smoothing with a sigma of 1.
                            ]]>
                    </help>
                </param>
                <param name="threshold_correction_factor" type="float" value="1.0" min="0.0" label="Threshold correction factor">
                    <help>
                        <![CDATA[
                            The value entered here adjusts the threshold either upwards or downwards, by multiplying it by this value.
                            A value of 1 means no adjustment, 0 to 1 makes the threshold more lenient and greater than 1 makes the threshold more stringent.
                            ]]>
                    </help>
                </param>
                <param name="threshold_lower" type="float" value="0.0" min="0.0" max="1.0" label="Lower bound on threshold">
                    <help>
                        <![CDATA[
                            This is helpful as a safety precaution: when the threshold as calculated automatically is clearly outside a reasonable range, the min/max allowable threshold will override the automatic threshold.
                            ]]>
                    </help>
                </param>
                <param name="threshold_upper" type="float" value="1.0" min="0.0" max="1.0" label="Upper bound on threshold"/>
                <conditional name="con_distinguish_clumped_objects">
                    <param name="distinguish_clumped_objects" type="select" label="Method to distinguish clumped objects">
                        <help>
                            <![CDATA[
                                This setting allows you to choose the method that is used to distinguish between individual objects that are touching each other (and not properly delineated as two objects by thresholding alone). In other words, this setting allows you to “declump” a large, merged object into individual objects of interest. To decide between these methods, you can run Test mode to see the results of each.
                                <br> - Intensity: For objects that tend to have only a single peak of brightness (e.g., objects that are brighter towards their interiors and dimmer towards their edges), this option counts each intensity peak as a separate object. The objects can be any shape, so they need not be round and uniform in size as would be required for the Shape option.
                                <br> - Shape: For cases when there are definite indentations separating objects. The image is converted to black and white (binary) and the shape determines whether clumped objects will be distinguished. The declumping results of this method are affected by the thresholding method you choose.
                                <br> - None: If objects are well separated and bright relative to the background, it may be unnecessary to attempt to separate clumped objects. Using the very fast None option, a simple threshold will be used to identify objects.
                                ]]>
                        </help>
                        <option value="Shape">Shape</option>
                        <option value="Intensity" selected="True">Intensity</option>
                        <option value="None">None</option>
                    </param>
                    <when value="Shape">
                        <expand macro="clumped_objects"/>
                    </when>
                    <when value="Intensity">
                        <expand macro="clumped_objects"/>
                    </when>
                    <when value="None"/>
                </conditional>
                <param name="fill_hole" type="select" label="Fill holes in identified objects">
                    <help>
                        <![CDATA[
                            This option controls how holes (regions of background surrounded by one or more objects) are filled in:
                            <br> - After both thresholding and declumping: Fill in holes that are smaller than the maximum object size prior to declumping and to fill in any holes after declumping.
                            <br> - After declumping only: Fill in holes located within identified objects after declumping.
                            <br> - Never: Leave holes within objects. Please note that if an object is located within a hole and this option is enabled, the object will be lost when the hole is filled in.
                            ]]>
                    </help>
                    <option value="Never">Never</option>
                    <option value="After both thresholding and declumping" selected="True">After both thresholding and declumping</option>
                    <option value="After declumping only">After declumping only</option>
                </param>

                <conditional name="con_handling_excessive">
                    <param name="excessive_handling" type="select" label="Handling of objects if excessive number of objects identified">
                        <help>
                            <![CDATA[
                                This setting deals with images that are segmented into an unreasonable number of objects. This might happen if the module calculates a low threshold or if the image has unusual artifacts. IdentifyPrimaryObjects can handle this condition in one of three ways:
                                <br> - Continue: Continue processing regardless if large numbers of objects are found.
                                <br> - Erase: Erase all objects if the number of objects exceeds the maximum. This results in an image with no primary objects. This option is a good choice if a large number of objects indicates that the image should not be processed; it can save a lot of time in subsequent Measure modules.
                                ]]>
                        </help>
                        <option value="Continue">Continue</option>
                        <option value="Erase">Erase</option>
                    </param>
                    <when value="Erase">
                        <param name="max_obj" type="integer" value="500" label="Maximum number of objects" help="This setting limits the number of objects in the image." />
                    </when>
                    <when value="Continue" />
                </conditional>
            </when>
        </conditional>
    </inputs>

    <outputs>
        <expand macro="output_pipeline_param" />
    </outputs>

    <tests>
        <test>
            <expand macro="test_input_pipeline_param" />
            <conditional name="con_advanced">
                <param name="advanced" value="Yes" />
                <param name="input_from_nat" value="DNA" />
                <param name="name_to_be_identified" value="Nuclei" />
                <param name="min_diameter" value="15" />
                <param name="max_diameter" value="200" />
                <param name="discard_outside_border" value="Yes" />
                <param name="discard_touching_border" value="Yes" />
                <conditional name="con_threshold_strategy">
                    <param name="threshold_strategy" value="Global" />
                </conditional>
                <conditional name="con_threshold_method">
                    <param name="threshold_method" value="Otsu" />
                    <conditional name="con_threshold_class">
                        <param name="threshold_class" value="Two classes" />
                    </conditional>
                </conditional>
                <param name="threshold_smoothing_scale" value="1.3488" />
                <param name="threshold_correction_factor" value="0.9" />
                <param name="threshold_lower" value="0.0" />
                <param name="threshold_upper" value="1.0" />
                <conditional name="con_distinguish_clumped_objects">
                    <param name="distinguish_clumped_objects" value="Shape" />
                    <conditional name="con_dividing_lines">
                        <param name="dividing_lines" value="Shape" />
                        <conditional name="con_smoothing_filter">
                            <param name="smoothing_filter" value="Yes" />
                        </conditional>
                        <conditional name="con_min_distance">
                            <param name="min_distance" value="Yes" />
                        </conditional>
                        <param name="speed_up" value="Yes" />
                    </conditional>
                </conditional>
                <conditional name="con_handling_excessive">
                    <param name="excessive_handling" value="Continue" />
                </conditional>
                <param name="fill_hole" value="After both thresholding and declumping" />
            </conditional>
            <expand macro="test_out_file" file="identify_primary_objects.txt" />
        </test>
    </tests>

    <help>
        <![CDATA[
            .. class:: infomark

            **What it does**

            This tool identifies biological objects of interest. It requires grayscale images containing bright objects on a dark background. Incoming images must be 2D (including 2D slices of 3D images); please use the Watershed module for identification of objects in 3D.

            @COMMON_HELP@
            ]]>
    </help>

    <expand macro="citations" />

</tool>

