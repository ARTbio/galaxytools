<tool id="cp-identifyprimaryobjects" name="IdentifyPrimaryObjects" version="19.05">
  <description>module of CellProfiler v3.1.9</description>
  <requirements>
     <requirement type="package" version="2.7.16">python</requirement>
  </requirements>

  <macros>
    <import>macros.xml</import>
    <xml name="ipo_common"> 
      <param name="input_from_nat" type="text" label="Select the input image (from NamesAndTypes)"/>
      <param name="name_to_be_identified" type="text" label="Name the primary objects to be identified" />
      <param name="min_diameter" type="text" label="Typical minimum diameter of objects, in pixel units (Min)" value="15" />
      <param name="max_diameter" type="text" label="Typical maximum diameter of objects, in pixel units (Max)" value="200" />

      <param name="discard_outside_border" type="select" display="radio" label="Discard objects outside the diameter range?">
        <option value="Yes">Yes</option>
        <option value="No">No</option>
      </param>
      <param name="discard_touching_border" type="select" display="radio" label="Discard objects touching the border of the image?">
        <option value="Yes">Yes</option>
        <option value="No">No</option>
      </param>
    </xml>

    <xml name="clumped_objects_params">
      <conditional name="con_smoothing_filter">
        <param name="smoothing_filter" type="select" display="radio" label="Automatically calculate size of smoothing filter for decluping?">
            <option value="Yes">Yes</option>
            <option value="No">No</option>
        </param>
        <when value="No">
            <param name="size_smoothing_filter" type="text" label="Size of smoothing filter"/>
        </when>
      </conditional>
      <conditional name="con_min_distance">
        <param name="min_distance" type="select" display="radio" label="Automatically calculate minimum allowed distance between local maxima?">
            <option value="Yes">Yes</option>
            <option value="No">No</option>
        </param>
        <when value="No">
            <param name="min_allowed_distance" type="text" label="Supress local maxima that are closer than this minimum allowed distance"/>
        </when>
      </conditional>  
      <param name="speed_up" type="select" display="radio" label="Speed up by using lower-resolution image to find local maxima?">    
        <option value="Yes">Yes</option>
        <option value="No">No</option>        
      </param>
    </xml>

    <xml name="clumped_objects">
      <conditional name="con_dividing_lines">
        <param name="dividing_lines" type="select" label="Method to draw dividing lines between clumped objects">
          <option value="Intensity">Intensity</option>
          <option value="Shape">Shape</option>
          <option value="Propagate">Propagate</option>
          <option value="None">None</option>
        </param>
        <when value="Shape">
          <expand macro="clumped_objects_params"/>
        </when>
        <when value="Intensity">
          <expand macro="clumped_objects_params"/>
        </when>
    </conditional>
    </xml>   
  </macros>
  <configfiles>
    <inputs name="inputs" filename="input.json" />

    <configfile name="script_file">
import json
import sys
import os

FOURSPACES="    "
NEWLINE="\n"

input_json_path = sys.argv[1]
input_pipeline= sys.argv[2]

params = json.load(open(input_json_path, "r"))

ipo = params['con_advanced']

adv = params['con_advanced']['advanced']


def write_ipo():
  f.write(NEWLINE)

  f.write("IdentifyPrimaryObjects:[module_num:"+str(new_count)+"|svn_version:\\'Unknown\\'|variable_revision_number:13|show_window:True|notes:\\x5B\\'Identify the nuclei from the DNA channel.\\', \\'PARAMS\\x3A\\', \\'- Typical diameter of objects (Min,Max)\\', \\'- Method to distinguish clumped objects\\x3A Shape/None. With Shape, the distance between the 2 centers can be changed.\\'\\x5D|batch_state:array(\\x5B\\x5D, dtype=uint8)|enabled:True|wants_pause:False]"+NEWLINE)

  if adv == "Yes":
      f.write(FOURSPACES+"Select the input image:"+ipo['input_from_nat']+NEWLINE)
      f.write(FOURSPACES+"Name the primary objects to be identified:"+ipo['name_to_be_identified']+NEWLINE)
      f.write(FOURSPACES+"Typical diameter of objects, in pixel units (Min,Max):"+str(ipo['min_diameter'])+","+str(ipo['max_diameter'])+NEWLINE)
      f.write(FOURSPACES+"Discard objects outside the diameter range?:"+ipo['discard_outside_border']+NEWLINE)
      f.write(FOURSPACES+"Discard objects touching the border of the image?:"+ipo['discard_touching_border']+NEWLINE)

      f.write(FOURSPACES+"Method to distinguish clumped objects:"+ipo['con_distinguish_clumped_objects']['distinguish_clumped_objects']+NEWLINE)


      if "con_dividing_lines" in ipo['con_distinguish_clumped_objects']:
          smoothing= ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter']['smoothing_filter']
          supress = ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_distance']      
          f.write(FOURSPACES+"Method to draw dividing lines between clumped objects:"+ipo['con_distinguish_clumped_objects']['con_dividing_lines']['dividing_lines']+NEWLINE)

          
          if smoothing == "Yes":
            f.write(FOURSPACES+"Size of smoothing filter:0"+NEWLINE)
          else: 
            f.write(FOURSPACES+"Size of smoothing filter:"+ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter']['size_smoothing_filter']+NEWLINE)

      
          if supress == "Yes":
            f.write(FOURSPACES+"Suppress local maxima that are closer than this minimum allowed distance:7"+NEWLINE)
          else:
            f.write(FOURSPACES+"Suppress local maxima that are closer than this minimum allowed distance:"+ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_allowed_distance']+NEWLINE)
          
          f.write(FOURSPACES+"Speed up by using lower-resolution image to find local maxima?:"+ipo['con_distinguish_clumped_objects']['con_dividing_lines']['speed_up']+NEWLINE)

      f.write(FOURSPACES+"Fill holes in identified objects?:"+ipo['fill_hole']+NEWLINE)

      if "con_dividing_lines" in ipo['con_distinguish_clumped_objects']:
        f.write(FOURSPACES+"Automatically calculate size of smoothing filter for declumping?:"+ ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_smoothing_filter']['smoothing_filter']+NEWLINE)
        f.write(FOURSPACES+"Automatically calculate minimum allowed distance between local maxima?:"+ipo['con_distinguish_clumped_objects']['con_dividing_lines']['con_min_distance']['min_distance']+NEWLINE)


      if "con_handling_excessive" in ipo:
        excessive = ipo['con_handling_excessive']['excessive_handling']

        f.write(FOURSPACES+"Handling of objects if excessive number of objects identified:"+ipo['con_handling_excessive']['excessive_handling']+NEWLINE)
        if excessive =="Continue":
          f.write(FOURSPACES+"Maximum number of objects:500"+NEWLINE)
        else:
          f.write(FOURSPACES+"Maximum number of objects:"+ipo['con_handling_excessive']['max_obj']+NEWLINE)

      f.write(FOURSPACES+"Use advanced settings?:"+ipo['advanced']+NEWLINE)
      f.write(FOURSPACES+"Threshold settings version:10"+NEWLINE)
      f.write(FOURSPACES+"Threshold strategy:"+ipo['con_threshold_strategy']['threshold_strategy']+NEWLINE)

      threshold_method=ipo['con_threshold_method']['threshold_method']
      f.write(FOURSPACES+"Thresholding method:"+threshold_method+NEWLINE)

      f.write(FOURSPACES+"Threshold smoothing scale:"+str(ipo['threshold_smoothing_scale'])+NEWLINE)
      f.write(FOURSPACES+"Threshold correction factor:"+str(ipo['threshold_correction_factor'])+NEWLINE)
      f.write(FOURSPACES+"Lower and upper bounds on threshold:"+ str(ipo['threshold_lower']) +","+ str(ipo['threshold_upper'])+NEWLINE)

      if threshold_method == "Manual":
        f.write(FOURSPACES+"Manual threshold:"+str(ipo['con_threshold_method']['manual_threshold'])+NEWLINE)      
      else:
        f.write(FOURSPACES+"Manual threshold:0"+NEWLINE)

      
      if threshold_method == "Measurement":
        f.write(FOURSPACES+"Select the measurement to threshold with:"+ipo['con_threshold_method']['threshold_measurement']+NEWLINE)
      else:
        f.write(FOURSPACES+"Select the measurement to threshold with:None"+NEWLINE)

      
      threshold_class = ipo['con_threshold_method']['con_threshold_class']['threshold_class']
      f.write(FOURSPACES+"Two-class or three-class thresholding?:"+threshold_class+NEWLINE)

      if threshold_class == "Three classes":
        f.write(FOURSPACES+"Assign pixels in the middle intensity class to the foreground or the background?:"+threshold_class['assign_pixel']+NEWLINE)
      else:
        f.write(FOURSPACES+"Assign pixels in the middle intensity class to the foreground or the background?:Foreground"+NEWLINE)


      if ipo['con_threshold_strategy']['threshold_strategy'] == "Adaptive":
        f.write(FOURSPACES+"Size of adaptive window:"+ipo['con_threshold_strategy']['adaptive_window']+NEWLINE)
      else:
        f.write(FOURSPACES+"Size of adaptive window:500"+NEWLINE)


      if threshold_method == "RobustBackground":
        f.write(FOURSPACES+"Lower outlier fraction:"+ipo['con_threshold_method']['lower_outlier_fraction']+NEWLINE)
        f.write(FOURSPACES+"Upper outlier fraction:"+ipo['con_threshold_method']['upper_outlier_fraction']+NEWLINE)
        f.write(FOURSPACES+"Averaging method:"+ipo['con_threshold_method']['avg_method']+NEWLINE)
        f.write(FOURSPACES+"Variance method:"+['variance_method']+NEWLINE)
        f.write(FOURSPACES+"# of deviations:"+ipo['con_threshold_method']['no_of_deviations']+NEWLINE)
      else:
        f.write(FOURSPACES+"Lower outlier fraction:0.05"+NEWLINE)
        f.write(FOURSPACES+"Upper outlier fraction:0.05"+NEWLINE)
        f.write(FOURSPACES+"Averaging method:Mean"+NEWLINE)
        f.write(FOURSPACES+"Variance method:Standard deviation"+NEWLINE)
        f.write(FOURSPACES+"# of deviations:2.0"+NEWLINE)

      f.write(FOURSPACES+"Thresholding method:"+threshold_method+NEWLINE) #This is a repeated entry, but needed for pipeline file
      


with open(input_pipeline) as fin:
  lines = fin.readlines()
  
  k,v= lines[4].strip().split(':')

  module_count = int(v)
  new_count = module_count+1
  lines[4]= k+":"+str(new_count)+"\n"
  with open("output","w") as f:
    f.writelines(lines)
    write_ipo()

f.close() 
    </configfile>
  </configfiles>
  <command><![CDATA[
        python $script_file $inputs $input_pipeline
  ]]></command>
  <inputs>
      <expand macro="input_pipeline_macro" /> 
      <conditional name="con_advanced">
        <param name="advanced" type="select"  display="radio" label="Use advanced settings?">
              <option value="No">No</option>
              <option value="Yes">Yes</option>
        </param>
        <when value="No">
          <expand macro="ipo_common" />
        </when>
        <when value="Yes">
          <expand macro="ipo_common" />
          <conditional name="con_threshold_strategy">
            <param name="threshold_strategy" type="select" label="Threshold strategy">
                <option value="Global">Global</option>
                <option value="Adaptive">Adaptive</option>
            </param>
            <when value="Adaptive">
              <param name="adaptive_window" type="text" label="Size of adaptive window"/>
            </when>            
          </conditional>
          <conditional name="con_threshold_method">
            <param name="threshold_method" type="select" label="Thresholding method">
              <option value="Manual">Manual</option>
              <option value="Measurement">Measurement</option>
              <option value="Minimum cross entropy">Minimum cross entropy</option>
              <option value="Otsu">Otsu</option>
              <option value="RobustBackground">RobustBackground</option>
            </param>
            <when value="Otsu">
              <conditional name="con_threshold_class">
                <param name="threshold_class" type="select" label="Two-class or three-class thresholding?">
                  <option value="Two classes">Two classes</option>
                  <option value="Three classes">Three classes</option>
                </param>
                <when value="Three classes">
                  <param name="assign_pixel" type="select" label="Assign pixels in the middle intensity class to the foreground or the background?">
                    <option value="Foreground">Foreground</option>
                    <option value="Background">Background</option>
                  </param>
                </when>
              </conditional>
            </when>
            <when value="Manual">
              <param name="manual_threshold" type="text" label="Manual threshold" />
            </when>
            <when value="RobustBackground">
              <param name="lower_outlier_fraction" type="float" value="0.05" label="Lower outlier fraction" />
              <param name="upper_outlier_fraction" type="float" value="0.05" label="Upper outlier fraction" />
              <param name="avg_method" type="select" label="Averaging method">
                <option value="Mean">Mean</option>
                <option value="Median">Median</option>
                <option value="Mode">Mode</option>
              </param>
              <param name="variance_method" type="select" label="Variance">
                <option value="Standard deviation">Standard deviation</option>
                <option value="Median absolute deviation">Median absolute deviation</option>                
              </param>
              <param name="no_of_deviations" type="float" value="2.0" label="# of deviations" />
            </when>
          </conditional>
          <param name="threshold_smoothing_scale" type="float" value="0.0" label="Threshold smoothing scale"/>
          <param name="threshold_correction_factor" type="float" value="0.0" label="Threshold correction factor"/>
          <param name="threshold_lower" type="float" value="0.0" label="Lower bounds on threshold"/>
          <param name="threshold_upper" type="float" value="1.0" label="Upper bounds on threshold"/>
          <conditional name="con_distinguish_clumped_objects">
            <param name="distinguish_clumped_objects" type="select" label="Method to distinguish clumped objects">
              <option value="Shape">Shape</option>
              <option value="Intensity">Intensity</option>
              <option value="None">None</option>
            </param>
            <when value="Shape">
              <expand macro="clumped_objects"/>
            </when>
            <when value="Intensity">
              <expand macro="clumped_objects"/>
            </when>
          </conditional>
          <param name="fill_hole" type="select" label="Fill holes in identified objects">
            <option value="Never">Never</option>
            <option value="After both thresholding and declumping">After both thresholding and declumping</option>
            <option value="After declumping only">After declumping only</option>
          </param>

          <conditional name="con_handling_excessive">
            <param name="excessive_handling" type="select" label="Handling of objects if excessive number of objects identified">
              <option value="Continue">Continue</option>
              <option value="Erase">Erase</option>
            </param>
            <when value="Erase">
              <param name="max_obj" type="integer" value="500" label="Maximum number of objects" />
            </when>
          </conditional>
        </when>
      </conditional>

  </inputs>
  <outputs>
	<expand macro="output_pipeline_macro" />
  </outputs>

  <stdio>
  	<exit_code range="1:" level="fatal" description="Error occured"/>
  </stdio>
  <tests>

  </tests>
  <help>
    This tool append the IdentifyPrimaryObjects module section to an existing pipeline file (.cppipe).

    Input: existing pipeline file

    Output: new pipeline file

    Combine this tool with "Common" and "CellProfiler" together to run the module alone.    

    Identify the nuclei from the DNA channel.
    
    PARAMS:
    
    - Typical diameter of objects (Min,Max)
    
    - Method to distinguish clumped objects: Shape/None. With Shape, the distance between the 2 centers can be changed.
  </help>
</tool>

